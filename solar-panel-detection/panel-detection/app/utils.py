# Code generated by GPT and then manually tested
#
# Converts pixel coordinates from a static map image (e.g., 416x416) into geographic coordinates
#   (latitude, longitude).
# Example (arbitrary values):
#   coords = bbox_pixels_to_coords([(120, 200), (200, 300), (150, 200), (200, 100)], 30.39, -9.3, 20)

import math

EARTH_RADIUS = 6378137
ORIGIN_SHIFT = 2 * math.pi * EARTH_RADIUS / 2.0
IMAGE_SIZE = 416  # we request 416x416 from google maps


def latlon_to_meters(lat, lon):
    mx = lon * ORIGIN_SHIFT / 180.0
    my = math.log(math.tan((90 + lat) * math.pi / 360.0)) * EARTH_RADIUS
    return mx, my


def meters_to_latlon(mx, my):
    lon = (mx / ORIGIN_SHIFT) * 180.0
    lat = (2 * math.atan(math.exp(my / EARTH_RADIUS)) - math.pi / 2) * (180.0 / math.pi)
    return lat, lon


def resolution(zoom: int):
    # resolution (meters/pixel) at zoom level
    return (2 * math.pi * EARTH_RADIUS) / (256 * 2**zoom)


def bbox_pixels_to_coords(
    bbox: iter, center_lat: float, center_lon: float, zoom: int, image_size: int = 416
):
    center_mx, center_my = latlon_to_meters(center_lat, center_lon)
    res = resolution(zoom)

    # Origin (top-left of image in meters)
    top_left_mx = center_mx - (image_size / 2) * res
    top_left_my = (
        center_my + (image_size / 2) * res
    )  # Y axis is inverted in pixel space

    coords = []
    for px, py in bbox:
        mx = top_left_mx + px * res
        my = top_left_my - py * res  # invert Y axis
        lat, lon = meters_to_latlon(mx, my)
        coords.append((lat, lon))
    return coords
